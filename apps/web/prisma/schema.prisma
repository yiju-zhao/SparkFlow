// SparkFlow Database Schema
// PostgreSQL with Prisma ORM

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// User & Authentication
// ============================================

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  notebooks Notebook[]
  notes     Note[]
  sessions  Session[]

  @@map("users")
}

// NextAuth.js session storage
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// ============================================
// Notebook & Sources
// ============================================

model Notebook {
  id          String  @id @default(cuid())
  userId      String
  name        String
  description String?

  // RagFlow Integration
  ragflowDatasetId String?
  ragflowAgentId   String?
  ragflowChatId    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  sources      Source[]
  chatSessions ChatSession[]
  messages     ChatMessage[]
  notes        Note[]

  // Unique constraint: one notebook name per user
  @@unique([userId, name])
  @@map("notebooks")
}

enum SourceType {
  DOCUMENT
  WEBPAGE
}

enum SourceStatus {
  UPLOADING
  PROCESSING
  READY
  FAILED
}

model Source {
  id                String       @id @default(cuid())
  notebookId        String
  title             String
  sourceType        SourceType
  url               String? // For webpages
  fileKey           String? // For documents (storage key)
  content           String?      @db.Text // Markdown content
  ragflowDocumentId String?
  status            SourceStatus @default(UPLOADING)
  errorMessage      String?
  metadata          Json?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Relations
  notebook Notebook      @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  images   SourceImage[]
  chunks   Chunk[]

  @@map("sources")
}

// Chunks from RagFlow for citation navigation
model Chunk {
  id             String @id // RagFlow chunk ID (primary key)
  sourceId       String
  contentPreview String @db.VarChar(200) // First ~200 chars for fuzzy matching
  position       Int    @default(0) // Order within document

  // Relations
  source Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([sourceId])
  @@map("chunks")
}

// Images extracted from documents (e.g., PDFs via MinerU)
model SourceImage {
  id           String   @id @default(cuid())
  sourceId     String
  originalName String // Original filename from MinerU (e.g., "image_0.png")
  storageKey   String // S3/MinIO object key
  contentType  String? // MIME type (e.g., "image/png")
  width        Int?
  height       Int?
  createdAt    DateTime @default(now())

  // Relations
  source Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([sourceId])
  @@map("source_images")
}

// ============================================
// Chat Sessions & Messages
// ============================================

enum SessionStatus {
  ACTIVE
  CLOSED
  ARCHIVED
}

model ChatSession {
  id         String        @id @default(uuid())
  notebookId String
  title      String        @default("New Chat")
  status     SessionStatus @default(ACTIVE)

  // LangGraph Integration
  langgraphThreadId String? @unique // Separate from session ID, can be regenerated

  // RagFlow Integration
  ragflowAgentId String?

  // Timestamps
  startedAt    DateTime  @default(now())
  lastActivity DateTime  @default(now())
  endedAt      DateTime?

  // Relations
  notebook Notebook      @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  messages ChatMessage[]

  @@map("chat_sessions")
}

enum MessageSender {
  USER
  ASSISTANT
}

model ChatMessage {
  id           String        @id @default(cuid())
  sessionId    String
  notebookId   String
  sender       MessageSender
  content      String
  metadata     Json? // sources, confidence, tokens, etc.
  messageOrder Int           @default(0)
  createdAt    DateTime      @default(now())

  // Relations
  session  ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  notebook Notebook    @relation(fields: [notebookId], references: [id], onDelete: Cascade)

  @@index([sessionId, messageOrder])
  @@map("chat_messages")
}

// ============================================
// Notes
// ============================================

model Note {
  id          String   @id @default(cuid())
  notebookId  String
  createdById String
  title       String
  content     String   @db.Text
  tags        String[] @default([])
  metadata    Json? // source message ID, etc.
  isPinned    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  notebook  Notebook @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  createdBy User     @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@map("notes")
}
