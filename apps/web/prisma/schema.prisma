// SparkFlow Database Schema
// PostgreSQL with Prisma ORM

generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  engineType    = "binary"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

// ============================================
// User & Authentication
// ============================================

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  notebooks Notebook[]
  notes     Note[]
  sessions  Session[]

  @@map("users")
}

// NextAuth.js session storage
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// ============================================
// Notebook & Sources
// ============================================

model Notebook {
  id          String  @id @default(cuid())
  userId      String
  name        String
  description String?

  // RagFlow Integration
  ragflowDatasetId String?
  ragflowAgentId   String?
  ragflowChatId    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  sources      Source[]
  chatSessions ChatSession[]
  messages     ChatMessage[]
  notes        Note[]

  // Unique constraint: one notebook name per user
  @@unique([userId, name])
  @@map("notebooks")
}

enum SourceType {
  DOCUMENT
  WEBPAGE
}

enum SourceStatus {
  UPLOADING
  PROCESSING
  READY
  FAILED
}

model Source {
  id                String       @id @default(cuid())
  notebookId        String
  title             String
  sourceType        SourceType
  url               String? // For webpages
  fileKey           String? // For documents (storage key)
  content           String?      @db.Text // Markdown content
  ragflowDocumentId String?
  status            SourceStatus @default(UPLOADING)
  errorMessage      String?
  metadata          Json?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Relations
  notebook Notebook      @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  images   SourceImage[]
  chunks   Chunk[]

  @@map("sources")
}

// Chunks from RagFlow for citation navigation
model Chunk {
  id             String  @id // RagFlow chunk ID (primary key)
  sourceId       String
  contentPreview String  @db.VarChar(200) // First ~100 chars for start position
  contentSuffix  String? @db.VarChar(200) // Last ~100 chars for end position
  position       Int     @default(0) // Order within document

  // Relations
  source Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([sourceId])
  @@map("chunks")
}

// Images extracted from documents (e.g., PDFs via MinerU)
model SourceImage {
  id           String   @id @default(cuid())
  sourceId     String
  originalName String // Original filename from MinerU (e.g., "image_0.png")
  storageKey   String // S3/MinIO object key
  contentType  String? // MIME type (e.g., "image/png")
  width        Int?
  height       Int?
  createdAt    DateTime @default(now())

  // Relations
  source Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([sourceId])
  @@map("source_images")
}

// ============================================
// Chat Sessions & Messages
// ============================================

enum SessionStatus {
  ACTIVE
  CLOSED
  ARCHIVED
}

model ChatSession {
  id         String        @id @default(uuid())
  notebookId String
  title      String        @default("New Chat")
  status     SessionStatus @default(ACTIVE)

  // LangGraph Integration
  langgraphThreadId String? @unique // Separate from session ID, can be regenerated

  // RagFlow Integration
  ragflowAgentId String?

  // Timestamps
  startedAt    DateTime  @default(now())
  lastActivity DateTime  @default(now())
  endedAt      DateTime?

  // Relations
  notebook Notebook      @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  messages ChatMessage[]

  @@map("chat_sessions")
}

enum MessageSender {
  USER
  ASSISTANT
}

model ChatMessage {
  id           String        @id @default(cuid())
  sessionId    String
  notebookId   String
  sender       MessageSender
  content      String
  metadata     Json? // sources, confidence, tokens, etc.
  messageOrder Int           @default(0)
  createdAt    DateTime      @default(now())

  // Relations
  session  ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  notebook Notebook    @relation(fields: [notebookId], references: [id], onDelete: Cascade)

  @@index([sessionId, messageOrder])
  @@map("chat_messages")
}

// ============================================
// Notes
// ============================================

model Note {
  id          String   @id @default(cuid())
  notebookId  String
  createdById String
  title       String
  content     String   @db.Text
  tags        String[] @default([])
  metadata    Json? // source message ID, etc.
  isPinned    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  notebook  Notebook @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  createdBy User     @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@map("notes")
}

// ============================================
// Conference Domain (Explore Feature)
// ============================================

model Venue {
  id          String     @id @default(cuid())
  name        String     @unique
  type        String?
  description String?

  instances   Instance[]

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@map("venues")
}

model Instance {
  id          String               @id @default(cuid())
  venueId     String
  venue       Venue                @relation(fields: [venueId], references: [id])

  year        Int
  name        String
  startDate   DateTime?
  endDate     DateTime?
  location    String?
  website     String?
  summary     String?              @db.Text

  publications Publication[]
  sessions     ConferenceSession[]

  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  @@unique([venueId, year])
  @@index([year])
  @@map("instances")
}

model Publication {
  id            String                 @id @default(cuid())
  instanceId    String
  instance      Instance               @relation(fields: [instanceId], references: [id])

  title         String
  authors       String[]
  abstract      String?                @db.Text
  summary       String?                @db.Text

  affiliations  String[]
  countries     String[]
  keywords      String[]
  researchTopic String?

  rating        Float?
  doi           String?
  pdfUrl        String?
  githubUrl     String?
  websiteUrl    String?

  sessions      SessionPublication[]

  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @updatedAt

  @@index([instanceId])
  @@index([researchTopic])
  @@map("publications")
}

model ConferenceSession {
  id          String                 @id @default(cuid())
  instanceId  String
  instance    Instance               @relation(fields: [instanceId], references: [id])

  title       String
  type        String?
  date        DateTime?
  startTime   String?
  endTime     String?
  location    String?
  speaker     String?

  abstract    String?                @db.Text
  overview    String?                @db.Text
  transcript  String?                @db.Text

  publications SessionPublication[]

  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt

  @@index([instanceId])
  @@index([type])
  @@map("conference_sessions")
}

model SessionPublication {
  sessionId     String
  session       ConferenceSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  publicationId String
  publication   Publication       @relation(fields: [publicationId], references: [id], onDelete: Cascade)

  presentationOrder Int?

  @@id([sessionId, publicationId])
  @@map("session_publications")
}
